<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camden Cats - Individual Statistics Report</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; }
        .sortable-header { cursor: pointer; transition: background-color 0.2s; }
        .sortable-header:hover { background-color: #374151; } /* gray-700 */
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Header -->
    <header class="bg-gray-800/50 backdrop-blur-sm shadow-md sticky top-0 z-20">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <a href="landing.html" class="flex items-center">
                        <img src="assets/camden_cats_logo.jpg" alt="Camden Cats Logo" class="h-10 w-10 rounded-full object-cover"
                             onerror="this.onerror=null; this.src='https://placehold.co/40x40/1a202c/ffffff?text=Logo';">
                        <span class="ml-3 font-semibold text-xl">Camden Cats Analytics</span>
                    </a>
                </div>
                <div class="flex items-center space-x-4">
                     <a href="landing.html" class="text-sm font-medium text-gray-400 hover:text-white transition-colors duration-200">Back to Dashboard</a>
                    <button id="logout-button" class="text-sm font-medium text-gray-400 hover:text-white transition-colors duration-200">Logout</button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div class="text-center">
            <h1 class="text-4xl font-bold tracking-tight">Individual Statistics Report</h1>
            <p class="mt-3 max-w-2xl mx-auto text-lg text-gray-400">Select a game to view the player statistics.</p>
        </div>

        <!-- File Loader -->
        <div class="mt-8 max-w-2xl mx-auto bg-gray-800 shadow-lg rounded-xl p-6">
             <h2 class="text-lg font-semibold text-white">Select Game Data File</h2>
             <div class="flex flex-col sm:flex-row gap-4 items-end mt-4">
                <div class="flex-grow w-full">
                    <label for="file-selector" class="sr-only">Game File</label>
                    <select id="file-selector" class="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-3">
                        <option value="">-- Please choose a game --</option>
                    </select>
                </div>
                <button id="load-file-btn" class="w-full sm:w-auto text-white bg-blue-600 hover:bg-blue-700 focus:ring-4 focus:outline-none focus:ring-blue-800 font-medium rounded-lg text-sm px-5 py-3 text-center transition duration-300 ease-in-out flex-shrink-0">Load Report</button>
             </div>
             <div id="loading-indicator" class="hidden text-center mt-4"><p class="text-gray-400">Loading data...</p></div>
        </div>

        <!-- Report Content Area -->
        <div id="report-content" class="hidden mt-8 max-w-7xl mx-auto space-y-8">
            <!-- Match Info Header -->
            <div class="bg-gray-800 shadow-lg rounded-xl p-6 text-center">
                <h2 id="match-info-title" class="text-2xl font-bold"></h2>
                <p id="match-info-date" class="text-gray-400"></p>
                <div id="match-result-container" class="flex justify-center mt-4"></div>
            </div>

            <!-- Top Performers Section -->
            <div id="top-performers-container">
                <h3 class="text-2xl font-bold text-center mb-6">Top Performers</h3>
                <div id="top-performers" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6"></div>
            </div>

            <!-- Full Statistics Table -->
            <div id="stats-table-container" class="bg-gray-800 shadow-lg rounded-xl overflow-hidden"></div>
        </div>
    </main>

    <script>
        // --- AUTHENTICATION CHECK ---
        /*
        if (sessionStorage.getItem('isLoggedIn') !== 'true') {
            window.location.href = 'index.html';
        }
        */
        document.getElementById('logout-button').addEventListener('click', function() {
            sessionStorage.removeItem('isLoggedIn');
            console.log("User has been logged out.");
            // window.location.href = 'index.html';
        });

        // --- DOM ELEMENT REFERENCES ---
        const fileSelector = document.getElementById('file-selector');
        const loadFileBtn = document.getElementById('load-file-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const reportContent = document.getElementById('report-content');
        const matchInfoTitle = document.getElementById('match-info-title');
        const matchInfoDate = document.getElementById('match-info-date');
        const matchResultContainer = document.getElementById('match-result-container');
        const topPerformersContainer = document.getElementById('top-performers');
        const statsTableContainer = document.getElementById('stats-table-container');

        // --- STATE AND CONFIGURATION ---
        let playerData = [];
        let sortState = { key: 'Name', direction: 'asc' };

        // --- GITHUB API CONFIGURATION ---
        const GITHUB_USER = 'NickPez36';
        const GITHUB_REPO = 'Camden_Match_Analytics';
        const GITHUB_PATH = 'data/Team_Review_Indv_XML';
        const API_URL = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents/${GITHUB_PATH}`;


        // --- DATA PROCESSING LOGIC ---

        /**
         * Initializes the application by fetching the list of XML files from the GitHub repository.
         */
        async function initializeApp() {
            try {
                const response = await fetch(API_URL);
                if (!response.ok) throw new Error(`GitHub API error: ${response.statusText}`);
                const files = await response.json();

                fileSelector.innerHTML = '<option value="">-- Please choose a game --</option>';

                files
                    .filter(file => file.type === 'file' && file.name.endsWith('.xml'))
                    .forEach(file => {
                        const option = document.createElement('option');
                        option.value = file.download_url;
                        option.textContent = file.name.replace(/_/g, ' ').replace('.xml', '').replace(' Indv', '');
                        option.dataset.fileName = file.name;
                        fileSelector.appendChild(option);
                    });
            } catch (error) {
                console.error('Failed to fetch file list from GitHub:', error);
            }
            loadFileBtn.addEventListener('click', loadSelectedFile);
        }

        /**
         * Loads and processes the selected XML file, automatically detecting encoding.
         */
        async function loadSelectedFile() {
            const selectedOption = fileSelector.options[fileSelector.selectedIndex];
            const fileUrl = selectedOption.value;
            const fileName = selectedOption.dataset.fileName;

            if (!fileUrl) {
                console.warn('Please select a file to load.');
                return;
            }

            loadingIndicator.classList.remove('hidden');
            reportContent.classList.add('hidden');

            try {
                const response = await fetch(fileUrl);
                if (!response.ok) throw new Error(`Network response was not ok. Could not fetch file: ${fileUrl}`);
                
                // [FIX] Automatically detect and handle both UTF-8 and UTF-16LE file encodings.
                const arrayBuffer = await response.arrayBuffer();
                const uint8 = new Uint8Array(arrayBuffer);
                let xmlText;

                // Check for UTF-16LE Byte Order Mark (BOM)
                if (uint8[0] === 0xFF && uint8[1] === 0xFE) {
                    const decoder = new TextDecoder('utf-16le');
                    xmlText = decoder.decode(arrayBuffer);
                } else {
                    // Default to UTF-8 for all other cases (including files with no BOM)
                    const decoder = new TextDecoder('utf-8');
                    xmlText = decoder.decode(arrayBuffer);
                }

                playerData = parseAndAggregateXML(xmlText);
                const matchDetails = parseFileName(fileName);
                renderReport(matchDetails);
                reportContent.classList.remove('hidden');
            } catch (error) {
                console.error('Error loading or processing file:', error);
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        /**
         * Parses the filename to extract match details like round, opposition, date, and result.
         */
        function parseFileName(fileName) {
            const nameWithoutExt = fileName.replace('.xml', '');
            const parts = nameWithoutExt.split('_');
            
            const round = parts[0].replace('RD', 'Round ');
            const result = parts[parts.length - 2].toUpperCase();
            const dateStr = parts[parts.length - 3];
            const opposition = parts.slice(1, -3).join(' ');

            let formattedDate = '';
            if (dateStr && dateStr.length === 8) {
                const day = dateStr.substring(0, 2);
                const month = dateStr.substring(2, 4);
                const year = dateStr.substring(4, 8);
                const dateObj = new Date(`${year}-${month}-${day}T00:00:00`);
                if (!isNaN(dateObj)) {
                    formattedDate = dateObj.toLocaleDateString('en-AU', {
                        day: 'numeric',
                        month: 'long',
                        year: 'numeric'
                    });
                }
            }
            return { round, opposition, date: formattedDate, result };
        }

        /**
         * Parses XML, aggregates stats, calculates assists and other derived stats.
         */
        function parseAndAggregateXML(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "application/xml");
            const instances = Array.from(xmlDoc.getElementsByTagName('instance'));

            const statsByPlayer = {};
            const allStatTypes = new Set(['Goal Assists', 'Score Assists']); // Pre-populate with new stats
            const eventLog = [];

            // First pass: Aggregate basic stats and create an event log
            instances.forEach(instance => {
                const codeNode = instance.querySelector('code');
                const playerCode = codeNode ? codeNode.textContent : null;
                const labelNodes = instance.querySelectorAll('label');
                let statType = null;

                for (const label of labelNodes) {
                    const group = label.querySelector('group');
                    if (group && group.textContent === 'Stat') {
                        statType = label.querySelector('text').textContent;
                        break;
                    }
                }

                if (playerCode && statType && playerCode !== 'Whistle') {
                    const standardizedPlayerName = playerCode.replace(/[.,]/g, ' ').replace(/\s+/g, ' ').trim();
                    
                    if (!statsByPlayer[standardizedPlayerName]) {
                        statsByPlayer[standardizedPlayerName] = {};
                    }
                    statsByPlayer[standardizedPlayerName][statType] = (statsByPlayer[standardizedPlayerName][statType] || 0) + 1;
                    allStatTypes.add(statType);
                    eventLog.push({ player: standardizedPlayerName, stat: statType });
                }
            });

            // Second pass: Calculate assists by analyzing the event log
            eventLog.forEach((event, i) => {
                if (event.stat === 'Goal' || event.stat === 'Behind') {
                    const scorer = event.player;
                    // Look backwards from the event before the score
                    for (let j = i - 1; j >= 0; j--) {
                        const prevEvent = eventLog[j];
                        // Find the last possession (Kick or Handball)
                        if (prevEvent.stat === 'Kick' || prevEvent.stat === 'Handball') {
                            const potentialAssister = prevEvent.player;
                            // A player cannot assist their own score
                            if (potentialAssister !== scorer) {
                                statsByPlayer[potentialAssister]['Score Assists'] = (statsByPlayer[potentialAssister]['Score Assists'] || 0) + 1;
                                if (event.stat === 'Goal') {
                                    statsByPlayer[potentialAssister]['Goal Assists'] = (statsByPlayer[potentialAssister]['Goal Assists'] || 0) + 1;
                                }
                                // Assist found, stop searching for this score
                                break; 
                            }
                            // If the scorer had the last possession, continue looking further back
                        }
                    }
                }
            });
            
            const aggregatedData = Object.entries(statsByPlayer).map(([playerName, stats]) => {
                const playerRecord = { Name: playerName };
                allStatTypes.forEach(stat => {
                    playerRecord[stat] = stats[stat] || 0;
                });
                return playerRecord;
            });

            // Calculate Total Disposals for each player
            aggregatedData.forEach(player => {
                const kicks = player['Kick'] || 0;
                const handballs = player['Handball'] || 0;
                player['Total Disposals'] = kicks + handballs;
            });
            
            return aggregatedData;
        }


        // --- RENDERING LOGIC ---

        function renderReport(matchDetails) {
            matchInfoTitle.textContent = `Camden Cats vs ${matchDetails.opposition}`;
            matchInfoDate.textContent = `${matchDetails.round} - ${matchDetails.date}`;

            renderMatchResult(matchDetails.result);
            renderTopPerformers();
            renderStatsTable();
        }

        function renderMatchResult(result) {
            matchResultContainer.innerHTML = '';
            let resultCardHTML = '';
            if (result === 'WIN') {
                resultCardHTML = `<div class="bg-green-600 text-white text-sm font-bold px-4 py-2 rounded-lg inline-block shadow-lg">MATCH WON</div>`;
            } else if (result === 'LOSS' || result === 'LOST') {
                resultCardHTML = `<div class="bg-red-600 text-white text-sm font-bold px-4 py-2 rounded-lg inline-block shadow-lg">MATCH LOST</div>`;
            }
            matchResultContainer.innerHTML = resultCardHTML;
        }

        function renderTopPerformers() {
            topPerformersContainer.innerHTML = '';
            if (playerData.length === 0) return;

            const allHeaders = Object.keys(playerData[0]);
            const statsToExclude = ['Name'];
            const statsToDisplay = allHeaders.filter(h => !statsToExclude.includes(h) && playerData.some(p => typeof p[h] === 'number'));

            statsToDisplay.forEach(stat => {
                const numericData = playerData.filter(p => p && typeof p[stat] === 'number');
                if (numericData.length === 0) return;

                const maxValue = Math.max(...numericData.map(p => p[stat]));
                 if (maxValue === 0) return;
                
                const topPlayers = playerData.filter(p => p[stat] === maxValue);

                if (topPlayers.length > 0) {
                    const playerNames = topPlayers.map(p => p.Name).join(', ');
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 p-5 rounded-xl text-center flex flex-col';
                    card.innerHTML = `
                        <p class="text-sm text-gray-400 font-medium flex-grow">Most ${stat.replace(/_/g, ' ')}</p>
                        <p class="text-3xl font-bold text-blue-400 my-2">${maxValue}</p>
                        <p class="text-base font-semibold text-white flex-grow">${playerNames}</p>
                    `;
                    topPerformersContainer.appendChild(card);
                }
            });
        }

        function renderStatsTable() {
            if (playerData.length === 0) {
                statsTableContainer.innerHTML = '';
                return;
            }

            const topValuesByStat = {};
            const statsToHighlight = Object.keys(playerData[0]).filter(h =>
                h !== 'Name' && playerData.some(p => typeof p[h] === 'number')
            );

            statsToHighlight.forEach(stat => {
                const values = playerData.map(p => p[stat]).filter(v => typeof v === 'number');
                if (values.length === 0) return;
                const uniqueSorted = [...new Set(values)].sort((a, b) => b - a);
                const threshold = uniqueSorted.length > 2 ? uniqueSorted[2] : uniqueSorted[uniqueSorted.length - 1];
                topValuesByStat[stat] = uniqueSorted.filter(v => v >= threshold && v > 0);
            });

            playerData.sort((a, b) => {
                const valA = a[sortState.key];
                const valB = b[sortState.key];
                const direction = sortState.direction === 'asc' ? 1 : -1;

                if (typeof valA === 'number' && typeof valB === 'number') {
                    return (valA - valB) * direction;
                }
                return String(valA).localeCompare(String(valB)) * direction;
            });
            
            const desiredOrder = ['Kick', 'Handball', 'Total Disposals', 'Mark', 'Tackle', 'Inside 50', 'Hit Out', 'Goal', 'Behind', 'Goal Assists', 'Score Assists', 'Direct Turnover'];
            const availableHeaders = Object.keys(playerData[0]).filter(h => h !== 'Name');
            const sortedHeaders = desiredOrder.filter(h => availableHeaders.includes(h));
            const remainingHeaders = availableHeaders.filter(h => !desiredOrder.includes(h));
            const headers = ['Name', ...sortedHeaders, ...remainingHeaders];


            let tableHTML = `<div class="overflow-x-auto"><table class="w-full text-sm text-left text-gray-400"><thead class="text-xs text-gray-400 uppercase bg-gray-700"><tr>`;

            headers.forEach(h => {
                const sortIndicator = sortState.key === h ? (sortState.direction === 'asc' ? ' ▲' : ' ▼') : '';
                tableHTML += `<th scope="col" class="px-6 py-3 sortable-header" data-sort-key="${h}">${h.replace(/_/g, ' ')}${sortIndicator}</th>`;
            });
            tableHTML += `</tr></thead><tbody>`;

            playerData.forEach(player => {
                tableHTML += `<tr class="border-b border-gray-700 hover:bg-gray-600/50">`;
                headers.forEach(header => {
                    const value = player[header] || 0; // Default to 0 if a stat is missing for a player
                    const isPlayerName = header === 'Name';

                    let cellClass = '';
                    if (topValuesByStat[header] && topValuesByStat[header].includes(value)) {
                        if (header === 'Direct Turnover') {
                            cellClass = 'bg-red-500 text-white font-bold rounded';
                        } else {
                            cellClass = 'bg-green-500 text-white font-bold rounded';
                        }
                    }

                    if (isPlayerName) {
                        tableHTML += `<th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">${value}</th>`;
                    } else {
                        tableHTML += `<td class="px-6 py-4 text-center ${cellClass}">${value}</td>`;
                    }
                });
                tableHTML += `</tr>`;
            });

            tableHTML += `</tbody></table></div>`;
            statsTableContainer.innerHTML = tableHTML;

            statsTableContainer.querySelectorAll('.sortable-header').forEach(th => {
                th.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.sortKey;
                    if (sortState.key === key) {
                        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortState.key = key;
                        sortState.direction = key === 'Name' ? 'asc' : 'desc';
                    }
                    renderStatsTable();
                });
            });
        }

        // --- INITIALIZATION ---
        initializeApp();
    </script>
</body>
</html>
