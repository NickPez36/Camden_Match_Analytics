<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camden Cats - Individual Statistics Report</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; }
        .sortable-header { cursor: pointer; transition: background-color 0.2s; }
        .sortable-header:hover { background-color: #374151; } /* gray-700 */
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Header -->
    <header class="bg-gray-800/50 backdrop-blur-sm shadow-md sticky top-0 z-20">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <a href="landing.html" class="flex items-center">
                        <img src="https://raw.githubusercontent.com/NickPez36/Camden_Match_Analytics/main/assets/camden_cats_logo.jpg" alt="Camden Cats Logo" class="h-10 w-10 rounded-full object-cover"
                             onerror="this.onerror=null; this.src='https://placehold.co/40x40/1a202c/ffffff?text=Logo';">
                        <span class="ml-3 font-semibold text-xl">Camden Cats Analytics</span>
                    </a>
                </div>
                <div class="flex items-center space-x-4">
                     <a href="landing.html" class="text-sm font-medium text-gray-400 hover:text-white transition-colors duration-200">Back to Dashboard</a>
                    <button id="logout-button" class="text-sm font-medium text-gray-400 hover:text-white transition-colors duration-200">Logout</button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div class="text-center">
            <h1 class="text-4xl font-bold tracking-tight">Individual Statistics Report</h1>
            <p class="mt-3 max-w-2xl mx-auto text-lg text-gray-400">Select a game to view the player statistics.</p>
        </div>

        <!-- File Loader -->
        <div class="mt-8 max-w-2xl mx-auto bg-gray-800 shadow-lg rounded-xl p-6">
             <h2 class="text-lg font-semibold text-white">Select Game Data File</h2>
             <div class="flex flex-col sm:flex-row gap-4 items-end mt-4">
                <div class="flex-grow w-full">
                    <label for="file-selector" class="sr-only">Game File</label>
                    <select id="file-selector" class="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-3">
                        <option value="">-- Please choose a game --</option>
                    </select>
                </div>
                <button id="load-file-btn" class="w-full sm:w-auto text-white bg-blue-600 hover:bg-blue-700 focus:ring-4 focus:outline-none focus:ring-blue-800 font-medium rounded-lg text-sm px-5 py-3 text-center transition duration-300 ease-in-out flex-shrink-0">Load Report</button>
             </div>
             <div id="loading-indicator" class="hidden text-center mt-4"><p class="text-gray-400">Loading data...</p></div>
        </div>

        <!-- Report Content Area -->
        <div id="report-content" class="hidden mt-8 max-w-7xl mx-auto space-y-8">
            <!-- Match Info Header -->
            <div class="bg-gray-800 shadow-lg rounded-xl p-6 text-center">
                <h2 id="match-info-title" class="text-2xl font-bold"></h2>
                <p id="match-info-date" class="text-gray-400"></p>
                <div id="match-result-container" class="flex justify-center mt-4"></div>
            </div>

            <!-- Top Performers Section -->
            <div id="top-performers-container">
                <h3 class="text-2xl font-bold text-center mb-6">Top Performers</h3>
                <div id="top-performers" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6"></div>
            </div>

            <!-- Full Statistics Table -->
            <div id="stats-table-container" class="bg-gray-800 shadow-lg rounded-xl overflow-hidden"></div>
        </div>
    </main>

    <script>
        // --- AUTHENTICATION CHECK ---
        document.getElementById('logout-button').addEventListener('click', function() {
            sessionStorage.removeItem('isLoggedIn');
            console.log("User has been logged out.");
        });

        // --- DOM ELEMENT REFERENCES ---
        const fileSelector = document.getElementById('file-selector');
        const loadFileBtn = document.getElementById('load-file-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const reportContent = document.getElementById('report-content');
        const matchInfoTitle = document.getElementById('match-info-title');
        const matchInfoDate = document.getElementById('match-info-date');
        const matchResultContainer = document.getElementById('match-result-container');
        const topPerformersContainer = document.getElementById('top-performers');
        const statsTableContainer = document.getElementById('stats-table-container');

        // --- STATE AND CONFIGURATION ---
        let playerData = [];
        let sortState = { key: 'Name', direction: 'asc' };

        // --- GITHUB API CONFIGURATION ---
        const GITHUB_USER = 'NickPez36';
        const GITHUB_REPO = 'Camden_Match_Analytics';
        const GITHUB_BRANCH = 'main';
        const TEAM_XML_FOLDER = "data/Team_Review__Team_XML";
        const INDV_XML_FOLDER = 'data/Team_Review_Indv_XML';
        const API_URL_INDV = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents/${INDV_XML_FOLDER}?ref=${GITHUB_BRANCH}`;
        const API_URL_TEAM = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents/${TEAM_XML_FOLDER}?ref=${GITHUB_BRANCH}`;
        const GITHUB_RAW_URL_BASE = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/${GITHUB_BRANCH}/`;

        // --- DATA PROCESSING LOGIC ---

        /**
         * Initializes the application by fetching the list of XML files from the GitHub repository.
         */
        async function initializeApp() {
            try {
                const response = await fetch(API_URL_INDV);
                if (!response.ok) throw new Error(`GitHub API error: ${response.statusText}`);
                const files = await response.json();

                fileSelector.innerHTML = '<option value="">-- Please choose a game --</option>';

                files
                    .filter(file => file.type === 'file' && file.name.endsWith('.xml'))
                    .forEach(file => {
                        const option = document.createElement('option');
                        option.value = file.path; // Use path for easier matching later
                        option.textContent = file.name.replace(/_/g, ' ').replace('.xml', '').replace(' Indv', '');
                        option.dataset.fileName = file.name;
                        fileSelector.appendChild(option);
                    });
            } catch (error) {
                console.error('Failed to fetch file list from GitHub:', error);
            }
            loadFileBtn.addEventListener('click', loadSelectedFile);
        }

        /**
         * Loads and processes the selected XML file, automatically detecting encoding.
         */
        async function loadSelectedFile() {
            const selectedOption = fileSelector.options[fileSelector.selectedIndex];
            const indvFilePath = selectedOption.value;
            const fileName = selectedOption.dataset.fileName;

            if (!indvFilePath) {
                console.warn('Please select a file to load.');
                return;
            }

            loadingIndicator.classList.remove('hidden');
            reportContent.classList.add('hidden');

            try {
                // Fetch and parse individual stats
                const indvFileUrl = GITHUB_RAW_URL_BASE + indvFilePath;
                const indvResponse = await fetch(indvFileUrl);
                if (!indvResponse.ok) throw new Error(`Could not fetch individual file: ${indvFileUrl}`);
                const indvBuffer = await indvResponse.arrayBuffer();
                const indvXmlText = decodeXmlBuffer(indvBuffer);
                playerData = parseAndAggregateXML(indvXmlText);

                // Fetch and process team data for advanced stats
                const teamFilePath = await findMatchingTeamFile(fileName);
                if (teamFilePath) {
                    const teamFileUrl = GITHUB_RAW_URL_BASE + teamFilePath;
                    const teamResponse = await fetch(teamFileUrl);
                    if (!teamResponse.ok) throw new Error(`Could not fetch team file: ${teamFileUrl}`);
                    const teamBuffer = await teamResponse.arrayBuffer();
                    const teamXmlText = decodeXmlBuffer(teamBuffer);
                    
                    // Run advanced analysis and merge results into playerData
                    runAdvancedAnalysis(indvXmlText, teamXmlText);
                } else {
                    console.warn("No matching team file found. Advanced stats will not be calculated.");
                }
                
                // Calculate Fantasy Points after all other stats are aggregated
                calculateFantasyPoints();

                const matchDetails = parseFileName(fileName);
                renderReport(matchDetails);
                reportContent.classList.remove('hidden');
            } catch (error) {
                console.error('Error loading or processing file:', error);
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }
        
        async function findMatchingTeamFile(individualFileName) {
            const roundIdentifier = individualFileName.split('_')[0];
            try {
                const response = await fetch(API_URL_TEAM);
                if (!response.ok) return null;
                const teamFiles = await response.json();
                const matchedFile = teamFiles.find(file => file.name.startsWith(roundIdentifier));
                return matchedFile ? matchedFile.path : null;
            } catch (error) {
                console.error("Could not search for team files:", error);
                return null;
            }
        }

        function decodeXmlBuffer(buffer) {
            const uint8 = new Uint8Array(buffer);
            if (uint8[0] === 0xFF && uint8[1] === 0xFE) return new TextDecoder('utf-16le').decode(buffer);
            if (uint8[0] === 0xFE && uint8[1] === 0xFF) return new TextDecoder('utf-16be').decode(buffer);
            return new TextDecoder('utf-8').decode(buffer);
        }

        function runAdvancedAnalysis(indvXmlText, teamXmlText) {
            const teamData = parseAnalysisXml(teamXmlText);
            const individualData = parseAnalysisXml(indvXmlText);
            const mergedData = mergeStats(individualData, teamData);

            const clearanceCounts = analyzeClearances(mergedData);
            const ruckmanEffectiveness = analyzeRuckmen(mergedData);

            // Merge new stats into the main playerData array
            playerData.forEach(player => {
                player['Clearances'] = clearanceCounts[player.Name] || 0;
                const ruckmanStats = ruckmanEffectiveness[player.Name];
                if (ruckmanStats && ruckmanStats.total > 0) {
                    player['Hitout to Win %'] = ((ruckmanStats.wins / ruckmanStats.total) * 100).toFixed(1);
                } else {
                    player['Hitout to Win %'] = 'N/A';
                }
            });
        }

        function parseAndAggregateXML(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "application/xml");
            const instances = Array.from(xmlDoc.getElementsByTagName('instance'));

            const statsByPlayer = {};
            const allStatTypes = new Set(['Goal Assists', 'Score Assists']);
            const eventLog = [];

            instances.forEach(instance => {
                const codeNode = instance.querySelector('code');
                const playerCode = codeNode ? codeNode.textContent : null;
                
                let statType = null;
                const labelNodes = instance.querySelectorAll('label');
                for (const label of labelNodes) {
                    const group = label.querySelector('group');
                    if (group && group.textContent === 'Stat') {
                        statType = label.querySelector('text').textContent;
                        break;
                    }
                }

                if (playerCode && statType && playerCode !== 'Whistle') {
                    const standardizedPlayerName = playerCode.replace(/[.,]/g, ' ').replace(/\s+/g, ' ').trim();
                    
                    if (!statsByPlayer[standardizedPlayerName]) {
                        statsByPlayer[standardizedPlayerName] = {};
                    }
                    statsByPlayer[standardizedPlayerName][statType] = (statsByPlayer[standardizedPlayerName][statType] || 0) + 1;
                    allStatTypes.add(statType);
                    eventLog.push({ player: standardizedPlayerName, stat: statType });
                }
            });

            eventLog.forEach((event, i) => {
                if (event.stat === 'Goal' || event.stat === 'Behind') {
                    const scorer = event.player;
                    for (let j = i - 1; j >= 0; j--) {
                        const prevEvent = eventLog[j];
                        if (prevEvent.stat === 'Kick' || prevEvent.stat === 'Handball') {
                            const potentialAssister = prevEvent.player;
                            if (potentialAssister !== scorer) {
                                statsByPlayer[potentialAssister]['Score Assists'] = (statsByPlayer[potentialAssister]['Score Assists'] || 0) + 1;
                                if (event.stat === 'Goal') {
                                    statsByPlayer[potentialAssister]['Goal Assists'] = (statsByPlayer[potentialAssister]['Goal Assists'] || 0) + 1;
                                }
                                break; 
                            }
                        }
                    }
                }
            });
            
            const aggregatedData = Object.entries(statsByPlayer).map(([playerName, stats]) => {
                const playerRecord = { Name: playerName };
                allStatTypes.forEach(stat => {
                    playerRecord[stat] = stats[stat] || 0;
                });
                return playerRecord;
            });

            aggregatedData.forEach(player => {
                player['Total Disposals'] = (player['Kick'] || 0) + (player['Handball'] || 0);
            });
            
            return aggregatedData;
        }

        function calculateFantasyPoints() {
            const fantasyPointsMap = {
                'Kick': 3, 'Handball': 2, 'Mark': 3, 'Tackle': 4,
                'Direct Turnover': -3, 'Hit Out': 1, 'Goal': 6, 'Behind': 1,
                'Clearances': 2, 'Score Assists': 2, 'Inside 50': 2
            };

            playerData.forEach(player => {
                let fantasyScore = 0;
                for (const stat in fantasyPointsMap) {
                    if (player[stat]) {
                        fantasyScore += player[stat] * fantasyPointsMap[stat];
                    }
                }
                player['Fantasy Points'] = fantasyScore;
            });
        }
        
        function parseAnalysisXml(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            if (xmlDoc.getElementsByTagName("parsererror").length > 0) throw new Error("Failed to parse XML for analysis.");
            return Array.from(xmlDoc.getElementsByTagName('instance')).map(instance => {
                const labels = Array.from(instance.querySelectorAll('label'));
                let stat = '', quarter = '';
                if (labels.length > 0) {
                    const statLabel = labels.find(l => l.querySelector('group')?.textContent === 'Stat');
                    const quarterLabel = labels.find(l => l.querySelector('group')?.textContent === 'Quarter');
                    if (statLabel) stat = statLabel.querySelector('text')?.textContent || '';
                    if (quarterLabel) quarter = quarterLabel.querySelector('text')?.textContent || '';
                    else quarter = labels[0].querySelector('text')?.textContent || '';
                }
                return {
                    start: parseFloat(instance.querySelector('start')?.textContent || 0),
                    end: parseFloat(instance.querySelector('end')?.textContent || 0),
                    code: instance.querySelector('code')?.textContent.replace(/[.,]/g, ' ').replace(/\s+/g, ' ').trim() || '',
                    stat: stat,
                };
            });
        }

        function mergeStats(individualData, teamData) {
            return teamData.map(teamEvent => ({
                ...teamEvent,
                playerActions: individualData.filter(playerAction =>
                    playerAction.start >= teamEvent.start && playerAction.start <= teamEvent.end
                )
            }));
        }
        
        function analyzeClearances(mergedData) {
            const clearanceCounts = {};
            const wonStoppages = mergedData.filter(event => event.code.includes('Stoppage Win'));
            wonStoppages.forEach(event => {
                const sortedActions = [...event.playerActions].sort((a, b) => a.start - b.start);
                const firstAction = sortedActions.find(a => a.stat === 'Handball' || a.stat === 'Kick');
                if (firstAction) {
                    const playerName = firstAction.code;
                    clearanceCounts[playerName] = (clearanceCounts[playerName] || 0) + 1;
                }
            });
            return clearanceCounts;
        }

        function analyzeRuckmen(mergedData) {
            const ruckmanStats = {};
            const stoppages = mergedData.filter(event => event.code.includes('Stoppage'));
            stoppages.forEach(event => {
                const hitOutActions = event.playerActions.filter(a => a.stat === 'Hit Out');
                const ruckmenInStoppage = [...new Set(hitOutActions.map(a => a.code))];
                ruckmenInStoppage.forEach(playerName => {
                    if (!ruckmanStats[playerName]) {
                        ruckmanStats[playerName] = { wins: 0, losses: 0, neutrals: 0, total: 0 };
                    }
                    ruckmanStats[playerName].total++;
                    if (event.code.includes('Win')) ruckmanStats[playerName].wins++;
                    else if (event.code.includes('Loss')) ruckmanStats[playerName].losses++;
                    else if (event.code.includes('Neutral')) ruckmanStats[playerName].neutrals++;
                });
            });
            return ruckmanStats;
        }

        // --- RENDERING LOGIC ---

        function renderReport(matchDetails) {
            matchInfoTitle.textContent = `Camden Cats vs ${matchDetails.opposition}`;
            matchInfoDate.textContent = `${matchDetails.round} - ${matchDetails.date}`;

            renderMatchResult(matchDetails.result);
            renderTopPerformers();
            renderStatsTable();
        }

        function renderMatchResult(result) {
            matchResultContainer.innerHTML = '';
            let resultCardHTML = '';
            if (result === 'WIN') {
                resultCardHTML = `<div class="bg-green-600 text-white text-sm font-bold px-4 py-2 rounded-lg inline-block shadow-lg">MATCH WON</div>`;
            } else if (result === 'LOSS' || result === 'LOST') {
                resultCardHTML = `<div class="bg-red-600 text-white text-sm font-bold px-4 py-2 rounded-lg inline-block shadow-lg">MATCH LOST</div>`;
            }
            matchResultContainer.innerHTML = resultCardHTML;
        }

        function renderTopPerformers() {
            topPerformersContainer.innerHTML = '';
            if (playerData.length === 0) return;

            const allHeaders = Object.keys(playerData[0]);
            const statsToExclude = ['Name'];
            const statsToDisplay = allHeaders.filter(h => !statsToExclude.includes(h) && playerData.some(p => typeof p[h] === 'number'));

            statsToDisplay.forEach(stat => {
                const numericData = playerData.filter(p => p && typeof p[stat] === 'number');
                if (numericData.length === 0) return;

                const maxValue = Math.max(...numericData.map(p => p[stat]));
                 if (maxValue === 0) return;
                
                const topPlayers = playerData.filter(p => p[stat] === maxValue);

                if (topPlayers.length > 0) {
                    const playerNames = topPlayers.map(p => p.Name).join(', ');
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 p-5 rounded-xl text-center flex flex-col';
                    card.innerHTML = `
                        <p class="text-sm text-gray-400 font-medium flex-grow">Most ${stat.replace(/_/g, ' ')}</p>
                        <p class="text-3xl font-bold text-blue-400 my-2">${maxValue}</p>
                        <p class="text-base font-semibold text-white flex-grow">${playerNames}</p>
                    `;
                    topPerformersContainer.appendChild(card);
                }
            });
        }

        function renderStatsTable() {
            if (playerData.length === 0) {
                statsTableContainer.innerHTML = '';
                return;
            }

            const topValuesByStat = {};
            const statsToHighlight = Object.keys(playerData[0]).filter(h =>
                h !== 'Name' && playerData.some(p => typeof p[h] === 'number')
            );

            statsToHighlight.forEach(stat => {
                const values = playerData.map(p => p[stat]).filter(v => typeof v === 'number');
                if (values.length === 0) return;
                const uniqueSorted = [...new Set(values)].sort((a, b) => b - a);
                const threshold = uniqueSorted.length > 2 ? uniqueSorted[2] : uniqueSorted[uniqueSorted.length - 1];
                topValuesByStat[stat] = uniqueSorted.filter(v => v >= threshold && v > 0);
            });

            playerData.sort((a, b) => {
                const valA = a[sortState.key];
                const valB = b[sortState.key];
                const direction = sortState.direction === 'asc' ? 1 : -1;

                if (typeof valA === 'number' && typeof valB === 'number') {
                    return (valA - valB) * direction;
                }
                return String(valA).localeCompare(String(valB)) * direction;
            });
            
            const desiredOrder = ['Kick', 'Handball', 'Total Disposals', 'Mark', 'Tackle', 'Clearances', 'Inside 50', 'Hit Out', 'Hitout to Win %', 'Goal', 'Behind', 'Goal Assists', 'Score Assists', 'Direct Turnover', 'Fantasy Points'];
            const availableHeaders = Object.keys(playerData[0]).filter(h => h !== 'Name');
            const sortedHeaders = desiredOrder.filter(h => availableHeaders.includes(h));
            const remainingHeaders = availableHeaders.filter(h => !desiredOrder.includes(h));
            const headers = ['Name', ...sortedHeaders, ...remainingHeaders];


            let tableHTML = `<div class="overflow-x-auto"><table class="w-full text-sm text-left text-gray-400"><thead class="text-xs text-gray-400 uppercase bg-gray-700"><tr>`;

            headers.forEach(h => {
                const sortIndicator = sortState.key === h ? (sortState.direction === 'asc' ? ' ▲' : ' ▼') : '';
                tableHTML += `<th scope="col" class="px-6 py-3 sortable-header" data-sort-key="${h}">${h.replace(/_/g, ' ')}${sortIndicator}</th>`;
            });
            tableHTML += `</tr></thead><tbody>`;

            playerData.forEach(player => {
                tableHTML += `<tr class="border-b border-gray-700 hover:bg-gray-600/50">`;
                headers.forEach(header => {
                    const value = player[header] || 0;
                    const isPlayerName = header === 'Name';

                    let cellClass = '';
                    if (topValuesByStat[header] && topValuesByStat[header].includes(value)) {
                        if (header === 'Direct Turnover') {
                            cellClass = 'bg-red-500 text-white font-bold rounded';
                        } else {
                            cellClass = 'bg-green-500 text-white font-bold rounded';
                        }
                    }

                    if (isPlayerName) {
                        tableHTML += `<th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">${value}</th>`;
                    } else {
                        tableHTML += `<td class="px-6 py-4 text-center ${cellClass}">${value}</td>`;
                    }
                });
                tableHTML += `</tr>`;
            });

            tableHTML += `</tbody></table></div>`;
            statsTableContainer.innerHTML = tableHTML;

            statsTableContainer.querySelectorAll('.sortable-header').forEach(th => {
                th.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.sortKey;
                    if (sortState.key === key) {
                        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortState.key = key;
                        sortState.direction = key === 'Name' ? 'asc' : 'desc';
                    }
                    renderStatsTable();
                });
            });
        }
         /**
         * Parses the filename to extract match details like round, opposition, date, and result.
         */
        function parseFileName(fileName) {
            const nameWithoutExt = fileName.replace('.xml', '');
            const parts = nameWithoutExt.split('_');
            
            const round = parts[0].replace('RD', 'Round ');
            const result = parts[parts.length - 2].toUpperCase();
            const dateStr = parts[parts.length - 3];
            const opposition = parts.slice(1, -3).join(' ');

            let formattedDate = '';
            if (dateStr && dateStr.length === 8) {
                const day = dateStr.substring(0, 2);
                const month = dateStr.substring(2, 4);
                const year = dateStr.substring(4, 8);
                const dateObj = new Date(`${year}-${month}-${day}T00:00:00`);
                if (!isNaN(dateObj)) {
                    formattedDate = dateObj.toLocaleDateString('en-AU', {
                        day: 'numeric',
                        month: 'long',
                        year: 'numeric'
                    });
                }
            }
            return { round, opposition, date: formattedDate, result };
        }

        // --- INITIALIZATION ---
        initializeApp();
    </script>
</body>
</html>
